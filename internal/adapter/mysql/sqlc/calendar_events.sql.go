// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calendar_events.sql

package repo

import (
	"context"
	"database/sql"
	"time"
)

const createCalendarEvents = `-- name: CreateCalendarEvents :execresult
INSERT INTO calendar_events (event_date, day_type_id, description)
VALUES (?, ?, ?)
`

type CreateCalendarEventsParams struct {
	EventDate   time.Time      `json:"eventDate"`
	DayTypeID   string         `json:"dayTypeId"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateCalendarEvents(ctx context.Context, arg CreateCalendarEventsParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCalendarEvents, arg.EventDate, arg.DayTypeID, arg.Description)
}

const deleteCalendarEvents = `-- name: DeleteCalendarEvents :exec
DELETE FROM calendar_events WHERE id = ?
`

func (q *Queries) DeleteCalendarEvents(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCalendarEvents, id)
	return err
}

const getCalendarEventsByDate = `-- name: GetCalendarEventsByDate :one
SELECT
    id,
    event_date,
    day_type_id,
    COALESCE(description, '') as description,
    created_at,
    updated_at
FROM calendar_events
WHERE event_date = ?
`

type GetCalendarEventsByDateRow struct {
	ID          string    `json:"id"`
	EventDate   time.Time `json:"eventDate"`
	DayTypeID   string    `json:"dayTypeId"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

func (q *Queries) GetCalendarEventsByDate(ctx context.Context, eventDate time.Time) (GetCalendarEventsByDateRow, error) {
	row := q.db.QueryRowContext(ctx, getCalendarEventsByDate, eventDate)
	var i GetCalendarEventsByDateRow
	err := row.Scan(
		&i.ID,
		&i.EventDate,
		&i.DayTypeID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCalendarEventsById = `-- name: GetCalendarEventsById :one
SELECT
    id,
    event_date,
    day_type_id,
    COALESCE(description, '') as description,
    created_at,
    updated_at
FROM calendar_events
WHERE id = ?
`

type GetCalendarEventsByIdRow struct {
	ID          string    `json:"id"`
	EventDate   time.Time `json:"eventDate"`
	DayTypeID   string    `json:"dayTypeId"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

func (q *Queries) GetCalendarEventsById(ctx context.Context, id string) (GetCalendarEventsByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCalendarEventsById, id)
	var i GetCalendarEventsByIdRow
	err := row.Scan(
		&i.ID,
		&i.EventDate,
		&i.DayTypeID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCalendarEventsForMonth = `-- name: GetCalendarEventsForMonth :many

SELECT
    id,
    event_date,
    day_type_id,
    COALESCE(description, '') as description,
    created_at,
    updated_at
FROM calendar_events
WHERE YEAR(event_date) = YEAR(?) AND MONTH(event_date) = MONTH(?)
ORDER BY event_date
`

type GetCalendarEventsForMonthParams struct {
	Year  time.Time `json:"year"`
	Month time.Time `json:"month"`
}

type GetCalendarEventsForMonthRow struct {
	ID          string    `json:"id"`
	EventDate   time.Time `json:"eventDate"`
	DayTypeID   string    `json:"dayTypeId"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

// ============================================
// calendar_events queries
// ============================================
func (q *Queries) GetCalendarEventsForMonth(ctx context.Context, arg GetCalendarEventsForMonthParams) ([]GetCalendarEventsForMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getCalendarEventsForMonth, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalendarEventsForMonthRow
	for rows.Next() {
		var i GetCalendarEventsForMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.EventDate,
			&i.DayTypeID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalendarEventsForYear = `-- name: GetCalendarEventsForYear :many
SELECT
    id,
    event_date,
    day_type_id,
    COALESCE(description, '') as description,
    created_at,
    updated_at
FROM calendar_events
WHERE YEAR(event_date) = YEAR(?)
ORDER BY event_date
`

type GetCalendarEventsForYearRow struct {
	ID          string    `json:"id"`
	EventDate   time.Time `json:"eventDate"`
	DayTypeID   string    `json:"dayTypeId"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

func (q *Queries) GetCalendarEventsForYear(ctx context.Context, year time.Time) ([]GetCalendarEventsForYearRow, error) {
	rows, err := q.db.QueryContext(ctx, getCalendarEventsForYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalendarEventsForYearRow
	for rows.Next() {
		var i GetCalendarEventsForYearRow
		if err := rows.Scan(
			&i.ID,
			&i.EventDate,
			&i.DayTypeID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCalendarEvents = `-- name: UpdateCalendarEvents :exec
UPDATE calendar_events
SET
    event_date = ?,
    day_type_id = ?,
    description = ?
WHERE id = ?
`

type UpdateCalendarEventsParams struct {
	EventDate   time.Time      `json:"eventDate"`
	DayTypeID   string         `json:"dayTypeId"`
	Description sql.NullString `json:"description"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateCalendarEvents(ctx context.Context, arg UpdateCalendarEventsParams) error {
	_, err := q.db.ExecContext(ctx, updateCalendarEvents,
		arg.EventDate,
		arg.DayTypeID,
		arg.Description,
		arg.ID,
	)
	return err
}
