// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_time_entries.sql

package repo

import (
	"context"
	"strings"
	"time"
)

const createUserTimeEntry = `-- name: CreateUserTimeEntry :exec
INSERT INTO user_time_entries (user_id, entry_date, day_type_id, hours_worked)
VALUES (?, ?, ?, ?)
`

type CreateUserTimeEntryParams struct {
	UserID      string    `json:"userId"`
	EntryDate   time.Time `json:"entryDate"`
	DayTypeID   string    `json:"dayTypeId"`
	HoursWorked string    `json:"hoursWorked"`
}

func (q *Queries) CreateUserTimeEntry(ctx context.Context, arg CreateUserTimeEntryParams) error {
	_, err := q.db.ExecContext(ctx, createUserTimeEntry,
		arg.UserID,
		arg.EntryDate,
		arg.DayTypeID,
		arg.HoursWorked,
	)
	return err
}

const deleteUserTimeEntries = `-- name: DeleteUserTimeEntries :exec
DELETE FROM user_time_entries WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteUserTimeEntries(ctx context.Context, ids []string) error {
	query := deleteUserTimeEntries
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const deleteUserTimeEntry = `-- name: DeleteUserTimeEntry :exec
DELETE FROM user_time_entries WHERE id = ?
`

func (q *Queries) DeleteUserTimeEntry(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUserTimeEntry, id)
	return err
}

const getTotalHoursForUserTimeEntriesByMonth = `-- name: GetTotalHoursForUserTimeEntriesByMonth :many
SELECT
    user_id,
    YEAR(entry_date) as year,
    MONTH(entry_date) as month,
    SUM(hours_worked) as total_hours
FROM user_time_entries
WHERE user_id = ? AND YEAR(entry_date) = ? AND MONTH(entry_date) = ?
GROUP BY user_id, YEAR(entry_date), MONTH(entry_date)
`

type GetTotalHoursForUserTimeEntriesByMonthParams struct {
	UserID string    `json:"userId"`
	Year   time.Time `json:"year"`
	Month  time.Time `json:"month"`
}

type GetTotalHoursForUserTimeEntriesByMonthRow struct {
	UserID     string      `json:"userId"`
	Year       int32       `json:"year"`
	Month      int32       `json:"month"`
	TotalHours interface{} `json:"totalHours"`
}

func (q *Queries) GetTotalHoursForUserTimeEntriesByMonth(ctx context.Context, arg GetTotalHoursForUserTimeEntriesByMonthParams) ([]GetTotalHoursForUserTimeEntriesByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalHoursForUserTimeEntriesByMonth, arg.UserID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalHoursForUserTimeEntriesByMonthRow
	for rows.Next() {
		var i GetTotalHoursForUserTimeEntriesByMonthRow
		if err := rows.Scan(
			&i.UserID,
			&i.Year,
			&i.Month,
			&i.TotalHours,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalHoursForUserTimeEntriesByYear = `-- name: GetTotalHoursForUserTimeEntriesByYear :many
SELECT
    user_id,
    YEAR(entry_date) as year,
    MONTH(entry_date) as month,
    SUM(hours_worked) as total_hours
FROM user_time_entries
WHERE user_id = ? AND YEAR(entry_date) = ?
GROUP BY user_id, YEAR(entry_date), MONTH(entry_date)
ORDER BY MONTH(entry_date)
`

type GetTotalHoursForUserTimeEntriesByYearParams struct {
	UserID string    `json:"userId"`
	Year   time.Time `json:"year"`
}

type GetTotalHoursForUserTimeEntriesByYearRow struct {
	UserID     string      `json:"userId"`
	Year       int32       `json:"year"`
	Month      int32       `json:"month"`
	TotalHours interface{} `json:"totalHours"`
}

func (q *Queries) GetTotalHoursForUserTimeEntriesByYear(ctx context.Context, arg GetTotalHoursForUserTimeEntriesByYearParams) ([]GetTotalHoursForUserTimeEntriesByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalHoursForUserTimeEntriesByYear, arg.UserID, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalHoursForUserTimeEntriesByYearRow
	for rows.Next() {
		var i GetTotalHoursForUserTimeEntriesByYearRow
		if err := rows.Scan(
			&i.UserID,
			&i.Year,
			&i.Month,
			&i.TotalHours,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTimeEntriesForMonth = `-- name: GetUserTimeEntriesForMonth :many

SELECT id, user_id, entry_date, day_type_id, hours_worked, created_at, updated_at
FROM user_time_entries
WHERE user_id = ? AND YEAR(entry_date) = YEAR(?) AND MONTH(entry_date) = MONTH(?)
ORDER BY entry_date
`

type GetUserTimeEntriesForMonthParams struct {
	UserID string    `json:"userId"`
	Year   time.Time `json:"year"`
	Month  time.Time `json:"month"`
}

// ============================================
// user_time_entries queries
// ============================================
func (q *Queries) GetUserTimeEntriesForMonth(ctx context.Context, arg GetUserTimeEntriesForMonthParams) ([]UserTimeEntry, error) {
	rows, err := q.db.QueryContext(ctx, getUserTimeEntriesForMonth, arg.UserID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTimeEntry
	for rows.Next() {
		var i UserTimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EntryDate,
			&i.DayTypeID,
			&i.HoursWorked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTimeEntryById = `-- name: GetUserTimeEntryById :one
SELECT id, user_id, entry_date, day_type_id, hours_worked, created_at, updated_at
FROM user_time_entries
WHERE id = ?
`

func (q *Queries) GetUserTimeEntryById(ctx context.Context, id string) (UserTimeEntry, error) {
	row := q.db.QueryRowContext(ctx, getUserTimeEntryById, id)
	var i UserTimeEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EntryDate,
		&i.DayTypeID,
		&i.HoursWorked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTimeEntryByIds = `-- name: GetUserTimeEntryByIds :many
SELECT id, user_id, entry_date, day_type_id, hours_worked, created_at, updated_at
FROM user_time_entries
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetUserTimeEntryByIds(ctx context.Context, ids []string) ([]UserTimeEntry, error) {
	query := getUserTimeEntryByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTimeEntry
	for rows.Next() {
		var i UserTimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EntryDate,
			&i.DayTypeID,
			&i.HoursWorked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserTimeEntries = `-- name: UpdateUserTimeEntries :exec
UPDATE user_time_entries
SET
    day_type_id = ?,
    hours_worked = ?
WHERE id IN (/*SLICE:ids*/?)
`

type UpdateUserTimeEntriesParams struct {
	DayTypeID   string   `json:"dayTypeId"`
	HoursWorked string   `json:"hoursWorked"`
	Ids         []string `json:"ids"`
}

func (q *Queries) UpdateUserTimeEntries(ctx context.Context, arg UpdateUserTimeEntriesParams) error {
	query := updateUserTimeEntries
	var queryParams []interface{}
	queryParams = append(queryParams, arg.DayTypeID)
	queryParams = append(queryParams, arg.HoursWorked)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateUserTimeEntry = `-- name: UpdateUserTimeEntry :exec
UPDATE user_time_entries
SET
    day_type_id = ?,
    hours_worked = ?
WHERE id = ?
`

type UpdateUserTimeEntryParams struct {
	DayTypeID   string `json:"dayTypeId"`
	HoursWorked string `json:"hoursWorked"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateUserTimeEntry(ctx context.Context, arg UpdateUserTimeEntryParams) error {
	_, err := q.db.ExecContext(ctx, updateUserTimeEntry, arg.DayTypeID, arg.HoursWorked, arg.ID)
	return err
}
